# -*- coding: utf-8 -*-
"""A3 group part B

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QAIiDfYtjdVUH8BubXiv7LaX1ByoRm8h
"""

import heapq

class Road:
    def __init__(self, road_id, name, length):
        self.road_id = road_id
        self.name = name
        self.length = length

    def __str__(self):
         return f"Road(id={self.road_id}, name={self.name}, length={self.length})"

class Intersection:
    def __init__(self, intersection_id):
        self.intersection_id = intersection_id

class Graph:
    MAX_INTERSECTIONS = 25  # Maximum number of intersections (vertices)

    def __init__(self):
        self.vertices = {}  # Dictionary to store vertices (intersections)
        self.edges = {}     # Dictionary to store edges (roads)

    def add_intersection(self, intersection_id):
        """
        Add an intersection to the graph if it doesn't already exist and the maximum limit has not been reached.

        Parameters:
            intersection_id (any): Identifier for the intersection.
        """
        if len(self.vertices) >= self.MAX_INTERSECTIONS:
            raise Exception(f"The maximum limit of {self.MAX_INTERSECTIONS} intersections has been reached.")
        if intersection_id not in self.vertices:
            self.vertices[intersection_id] = Intersection(intersection_id)

    def add_road(self, road_id, start_intersection, end_intersection, name, length):
        """
        Add a road to the graph.

        Parameters:
            road_id (any): Identifier for the road.
            start_intersection (any): Identifier for the starting intersection of the road.
            end_intersection (any): Identifier for the ending intersection of the road.
            name (str): Name of the road.
            length (float): Length of the road.
        """
        self.add_intersection(start_intersection)
        self.add_intersection(end_intersection)
        self.edges[(start_intersection, end_intersection)] = Road(road_id, name, length)

# Test Case 1: Adding exactly 20 vertices and some roads
graph1 = Graph()

try:
    # Adding 20 intersections
    for i in range(1, 21):  # This will add intersections with IDs 1 through 20
        graph1.add_intersection(i)

    # Adding some roads between the added intersections
    graph1.add_road("A678", 1, 2, "Main Street", 10)  # Connects intersection 1 and 2
    graph1.add_road("B276", 3, 4, "Second Street", 15) # Connects intersection 3 and 4
    graph1.add_road("C367", 5, 6, "Third Street", 20)  # Connects intersection 5 and 6

    # Since we are only adding 20 intersections, there should be no error
    print("Test Case 1 Passed: 20 vertices and roads added successfully.")
except Exception as e:
    print(f"Test Case 1 Failed: {e}")

# Test Case 2: Attempting to add more than 25 vertices
graph2 = Graph()

# Trying to add 26 intersections - should raise an exception
try:
    for i in range(1, Graph.MAX_INTERSECTIONS + 2):
        graph2.add_intersection(i)
except Exception as e:
    print("Error in Graph 2:", e)

# Attempt to print out the vertices and roads; only vertices up to the limit should be present
print("Vertices in Graph 2:", graph2.vertices.keys())

# List of 25 vertices as requested
vertices_list = list(graph1.vertices.keys())
print("List of 25 vertices:", vertices_list)

# Requirement 2: Modeling Package Distribution
class Road:
    def __init__(self, road_id, name, length):
        # Initialize a Road instance with an ID, name, and length.
        # The length might represent the road's physical distance.
        self.road_id = road_id
        self.name = name
        self.length = length

class Intersection:
    def __init__(self, intersection_id):
        # Initialize an Intersection with a unique identifier.
        self.intersection_id = intersection_id

class Graph:
    # Set a maximum number of intersections allowed in the graph.
    MAX_INTERSECTIONS = 25

    def __init__(self):
        # Initialize a Graph with empty dictionaries for vertices (intersections)
        # and edges (roads connecting intersections).
        self.vertices = {}
        self.edges = {}

    def add_intersection(self, intersection_id):
        # Add an intersection to the graph ensuring the total number does not exceed the limit.
        # Raise an exception if the maximum limit is reached.
        if len(self.vertices) >= self.MAX_INTERSECTIONS:
            raise Exception(f"The maximum limit of {self.MAX_INTERSECTIONS} intersections has been reached.")
        # Add the intersection if it is not already present.
        if intersection_id not in self.vertices:
            self.vertices[intersection_id] = Intersection(intersection_id)

    def add_road(self, road_id, start_intersection, end_intersection, name, length):
        # Add a road to the graph, ensuring both endpoints (intersections) are added to the graph.
        self.add_intersection(start_intersection)
        self.add_intersection(end_intersection)
        # Store the road as edges in both directions to represent bidirectional travel.
        self.edges[(start_intersection, end_intersection)] = Road(road_id, name, length)
        self.edges[(end_intersection, start_intersection)] = Road(road_id, name, length)

    def connect_house_to_intersection(self, house_id, nearest_intersection):
        # Connect a house to its nearest intersection by adding a short road.
        # The house is treated as an intersection for simplicity.
        self.add_intersection(house_id)
        self.add_road(f"Road_{house_id}_to_{nearest_intersection}",
                      house_id, nearest_intersection,
                      f"AccessRoad_{house_id}", 0.1)

    def get_neighbors(self, node):
        # Retrieve neighboring intersections and their associated road lengths from a given node.
        neighbors = []
        for (start, end), road in self.edges.items():
            if start == node:
                neighbors.append((end, road.length))
            elif end == node:
                neighbors.append((start, road.length))
        return neighbors

    def greedy_package_distribution(self, start):
        # Implement a greedy algorithm to distribute packages starting from a warehouse.
        # It always selects the nearest unvisited intersection until all are visited.
        visited = set()
        path = [start]
        current_location = start
        total_distance = 0

        while len(visited) < len(self.vertices) - 1:  # Excluding the warehouse itself
            neighbors = self.get_neighbors(current_location)
            unvisited_neighbors = [(node, distance) for node, distance in neighbors if node not in visited and node != current_location]
            if not unvisited_neighbors:
                break  # No unvisited neighbors left
            next_location, distance_to_next = min(unvisited_neighbors, key=lambda x: x[1])
            visited.add(next_location)
            path.append(next_location)
            total_distance += distance_to_next
            current_location = next_location

        return path, total_distance

# test case 3
graph = Graph()
# Add intersections, roads, and houses
graph.add_intersection('Warehouse')
graph.add_intersection('A')
graph.add_intersection('B')
graph.add_road('R1', 'Warehouse', 'A', 'Main St', 10)
graph.add_road('R2', 'A', 'B', '1st Ave', 20)
graph.connect_house_to_intersection('House1', 'A')
graph.connect_house_to_intersection('House2', 'B')

# Find the package distribution path starting from the warehouse
distribution_path, distribution_distance = graph.greedy_package_distribution('Warehouse')
print("Distribution path:", distribution_path)
print("Total distance traveled:", distribution_distance)

#test case 4
#Add more intersections, roads, and houses
graph.add_intersection('C')
graph.add_intersection('D')
graph.add_intersection('E')
graph.add_road('R3', 'B', 'C', '2nd Ave', 15)
graph.add_road('R4', 'C', 'D', '3rd Ave', 25)
graph.add_road('R5', 'D', 'E', '4th Ave', 30)
graph.add_road('R6', 'E', 'Warehouse', '5th Ave', 20)
graph.connect_house_to_intersection('House3', 'C')
graph.connect_house_to_intersection('House4', 'D')
graph.connect_house_to_intersection('House5', 'E')

# Perform package distribution from the warehouse
distribution_path, distribution_distance = graph.greedy_package_distribution('Warehouse')
print("Distribution path for Test Case 4:", distribution_path)
print("Total distance traveled for Test Case 4:", distribution_distance)

#requirment 3 shortest ditance
def dijkstra_shortest_path(self, start_intersection):
    """
    Calculate the shortest path from a starting intersection to all other intersections using Dijkstra's algorithm.

    This algorithm uses a priority queue to dynamically select the next vertex with the minimum distance accumulated so far.

    Parameters:
        start_intersection (any): Identifier for the starting intersection.

    Returns:
        dict: A dictionary containing the shortest distances from the starting intersection to all other intersections.
    """
    # Check if the starting intersection exists in the vertices set.
    if start_intersection not in self.vertices:
        raise ValueError("Starting intersection does not exist in the graph.")

    # Initialize all distances from the start intersection to others as infinity. Set the start intersection's distance to zero.
    distances = {vertex: float('inf') for vertex in self.vertices}
    distances[start_intersection] = 0

    # Priority queue to hold vertices to explore; starts with the start vertex.
    queue = [(0, start_intersection)]

    while queue:
        # Pop the vertex with the smallest distance from the queue.
        current_distance, current_intersection = heapq.heappop(queue)

        # Only continue if the popped distance is the smallest recorded so far for this vertex.
        if current_distance > distances[current_intersection]:
            continue

        # Explore each neighboring intersection.
        for neighbor_intersection in self.get_neighbors(current_intersection):
            # Ensure there is a direct connection between current and neighbor intersection.
            if (current_intersection, neighbor_intersection) not in self.edges:
                continue  # Skip if no direct edge

            # Calculate the new distance to this neighbor.
            edge_length = self.edges[(current_intersection, neighbor_intersection)]
            distance_to_neighbor = current_distance + edge_length
            # If a shorter path to the neighbor is found, update the path and add to the queue.
            if distance_to_neighbor < distances[neighbor_intersection]:
                distances[neighbor_intersection] = distance_to_neighbor
                heapq.heappush(queue, (distance_to_neighbor, neighbor_intersection))

    return distances

def get_neighbors(self, intersection_id):
    """
    Retrieve all neighboring intersections connected by a direct road from the specified intersection.

    This function checks for outgoing edges from the given intersection and returns the endpoints of those edges.

    Parameters:
        intersection_id (any): Identifier for the intersection.

    Returns:
        list: A list of identifiers for neighboring intersections that are directly connected by roads.
    """
    # List all intersections that are connected directly from the specified intersection.
    # Include edges starting from this intersection.
    return [end for (start, end) in self.edges.keys() if start == intersection_id] + [start for (start, end) in self.edges.keys() if end == intersection_id]

import heapq

class Graph:
    def __init__(self):
        # Initializes an empty set of vertices and an empty dictionary for edges.
        self.vertices = set()
        self.edges = {}

    def add_vertex(self, vertex):
        # Adds a vertex to the set of vertices.
        self.vertices.add(vertex)

    def add_edge(self, start, end, length):
        # Adds a directed edge with a specified length from start vertex to end vertex.
        self.edges[(start, end)] = length

    def dijkstra_shortest_path(self, start_intersection):
        # Implements Dijkstra's algorithm to find the shortest path from a given start vertex.
        if start_intersection not in self.vertices:
            raise ValueError("Starting intersection does not exist in the graph.")

        # Initialize distances from start vertex to all others as infinity, and zero for start vertex.
        distances = {vertex: float('inf') for vertex in self.vertices}
        distances[start_intersection] = 0
        queue = [(0, start_intersection)]

        while queue:
            # Extracts vertex with the smallest distance from priority queue.
            current_distance, current_intersection = heapq.heappop(queue)
            # Skip processing if we find a longer distance in the queue.
            if current_distance > distances[current_intersection]:
                continue

            # Update distances to each neighbor of the current vertex.
            for neighbor_intersection in self.get_neighbors(current_intersection):
                edge = (current_intersection, neighbor_intersection)
                if edge not in self.edges:
                    continue
                distance_to_neighbor = current_distance + self.edges[edge]
                if distance_to_neighbor < distances[neighbor_intersection]:
                    distances[neighbor_intersection] = distance_to_neighbor
                    heapq.heappush(queue, (distance_to_neighbor, neighbor_intersection))

        return distances

    def get_neighbors(self, intersection_id):
        # Returns a list of end vertices (neighbors) that start from the given vertex.
        return [end for start, end in self.edges.keys() if start == intersection_id]

# Example of using the Graph class to set up vertices and edges and then calculate shortest paths.
graph = Graph()
graph.add_vertex('A')
graph.add_vertex('B')
graph.add_vertex('C')
graph.add_vertex('D')
graph.add_vertex('E')

graph.add_edge('A', 'B', 4)
graph.add_edge('A', 'C', 2)
graph.add_edge('B', 'C', 5)
graph.add_edge('B', 'D', 10)
graph.add_edge('C', 'E', 3)
graph.add_edge('D', 'E', 4)

# Test Case 5 - Validate that Dijkstra's algorithm computes correct shortest paths from vertex 'A'.
start = 'A'
expected_distances = {'A': 0, 'B': 4, 'C': 2, 'D': 14, 'E': 5}
actual_distances = graph.dijkstra_shortest_path(start)
assert actual_distances == expected_distances, f"Test Case 5 failed: {actual_distances}"

# Test Case 6 - Validate that Dijkstra's algorithm computes correct shortest paths from vertex 'D'.
start = 'D'
expected_distances = {'A': float('inf'), 'B': float('inf'), 'C': float('inf'), 'D': 0, 'E': 4}
actual_distances = graph.dijkstra_shortest_path(start)
assert actual_distances == expected_distances, f"Test Case 6 failed: {actual_distances}"

print("Test Case 6 passed successfully!")
print("Both test cases passed successfully!")